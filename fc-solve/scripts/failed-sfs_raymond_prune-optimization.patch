diff --git a/fc-solve/source/freecell.c b/fc-solve/source/freecell.c
index 97f0d72e..b2d42b2b 100644
--- a/fc-solve/source/freecell.c
+++ b/fc-solve/source/freecell.c
@@ -126,7 +126,7 @@ static inline void sort_derived_states(
  * */
 DECLARE_MOVE_FUNCTION(fc_solve_sfs_move_freecell_cards_to_founds)
 {
-    tests_define_accessors_no_stacks();
+    tests_define_accessors_no_stacks(tests_state_context_val);
 
 #ifndef HARD_CODED_NUM_FREECELLS
     SET_GAME_PARAMS();
@@ -1384,7 +1384,8 @@ extern fcs_collectible_state_t *fc_solve_sfs_raymond_prune(
     fc_solve_soft_thread_t *const soft_thread,
     fcs_kv_state_t *const raw_ptr_state_raw)
 {
-    tests_define_accessors();
+#define EMPTY
+    tests_define_accessors__generic(EMPTY);
     STACKS__SET_PARAMS();
 
     sfs_check_state_begin();
@@ -1450,14 +1451,9 @@ extern fcs_collectible_state_t *fc_solve_sfs_raymond_prune(
     {
         return NULL;
     }
-    fcs_derived_states_list_t derived_states_list_struct = {
-        .states = NULL, .num_states = 0};
-#define derived_states_list (&derived_states_list_struct)
-    sfs_check_state_end();
-#undef derived_states_list
-    register fcs_collectible_state_t *const ptr_next_state =
-        derived_states_list_struct.states[0].state_ptr;
-    free(derived_states_list_struct.states);
+    register const_AUTO(ptr_next_state,
+        fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw,
+            &pass_new_state FCS__pass_moves(moves)));
     /*
      * Set the GENERATED_BY_PRUNING flag uncondtionally. It won't
      * hurt if it's already there, and if it's a state that was
diff --git a/fc-solve/source/meta_move_funcs_helpers.h b/fc-solve/source/meta_move_funcs_helpers.h
index cabcaee6..e773632f 100644
--- a/fc-solve/source/meta_move_funcs_helpers.h
+++ b/fc-solve/source/meta_move_funcs_helpers.h
@@ -126,14 +126,14 @@ static inline void fc_solve_move_sequence_function(
 #define tests_define_accessors_move_stack()
 #endif
 
+#define tests_state_context_val int state_context_value = 0;
 /*
  * This macro defines these accessors to have some value.
  * */
-#define tests_define_accessors_no_stacks()                                     \
+#define tests_define_accessors_no_stacks(MORE)                                 \
     fc_solve_hard_thread_t *const hard_thread = soft_thread->hard_thread;      \
     tests_define_accessors_move_stack();                                       \
-    int state_context_value = 0;                                               \
-    fcs_kv_state_t pass_new_state;                                             \
+    MORE fcs_kv_state_t pass_new_state;                                        \
     tests_define_accessors_freecell_only();                                    \
     tests_define_accessors_rcs_states()
 
@@ -145,10 +145,12 @@ static inline void fc_solve_move_sequence_function(
 #define tests_define_indirect_stack_states_accessors()
 #endif
 
-#define tests_define_accessors()                                               \
-    tests_define_accessors_no_stacks();                                        \
+#define tests_define_accessors__generic(MORE)                                  \
+    tests_define_accessors_no_stacks(MORE);                                    \
     tests_define_indirect_stack_states_accessors()
 
+#define tests_define_accessors()                                               \
+    tests_define_accessors__generic(tests_state_context_val)
 #define my_copy_stack(idx)                                                     \
     fcs_copy_stack(                                                            \
         new_state_key, *(pass_new_state.val), idx, indirect_stacks_buffer)
