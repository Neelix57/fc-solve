--- Pressing ---
    
    Arch Doc:
    ---------
    
    * Hyperlink to the terms from someplaces in the main document

    * Document the mapping of aliases -> test functions.

* Change char *'s to const char *'s in the API.
    - DONE partially

* Process the prefix.h.in etc files inside Makefile.am using sed.

* Implement the move stacks over-riding in the derived states list, so
move stacks won't be allocated excessively.

* Implement the derived states ordering.

* Implement the perl script that displays the moves in a human viewable
fashion.

* Implement the mapping of names -> test functions.
    - Done partially

* Implement Patsolve's state ordering.

    - Afterwards:

    * Time the patsolve's scans into the atomic moves scans database,
    and create an optimized meta-scan.

* Make sure fc-solve -opt works.

--- Non-pressing ---

* Convert some of the documentation to Perl-POD or DocBook.

* Integrate the patsolve's prioritization and mixed BFS/DFS scan.

* Make the code splint-clean.

* Write an architecture document.

* Write a Perl Script to parse, analyze and do a sanity check for a solution.
(-p -t -sam)

* Write a multi-threaded version and see if it runs ok.

* Write a multi-process client/server program.

* Port to Java (?). Note: the only reason I want to do it is so it will be
able to run inside an applet of a web-browser. Surf to some URL and have
a Freecell implementation that can solve itself.

Great thanks to Sun who made sure Java has a C/C++-like syntax but is so
much incompatible. (and kudos to the Internet C++ project who aims to create
a virtual machine with a proper gcc backend, so it will be compatible)

* Integrate into GNOME Freecell and/or GNOME AisleRiot and/or PySol.

* Code algorithms for similiar solitaire games. (maybe a perl program that 
generates C code). - DONE partialy

* Comment the code.

* Add a switch to ask the user if he wants to continue and enter a bigger 
iterations limit.

* Add a more verbose preset error handling. 
(explain why it could not be applied).

* Check for unmalloced data and if so gracefully exit.

* Add a limit to stacks number (in the case of Indirect Stack States),
number of states that are stored anywhere, etc.

* Experiment with a delta-based state storage.

* Code a generic tests grouping.

* Interactive mode? Continue a scan that reached its limit.

