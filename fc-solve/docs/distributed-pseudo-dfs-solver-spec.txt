Distributed Pseudo-DFS Solver SPEC:
===================================

Description:
------------

The pseduo-DFS solver will traverse a board using a stack of states and their
derived states (while making sure derived states do not repeat after first
encountered.). The primary item of communication will be a
Coordinates-Sequence (CoordSeq) that is:

struct CoordSeq
{
    int64_t depth;
    int32_t coords[0 .. depth-1];
}

This is generated when traversing the board using a predefined preset (say
"-to 01ABCDE -sp r:tf") using pseudo-DFS with the assumption that the states
collection/lookup only holds the states that were discovered earlier in the
stack. (There's also a local (per-client) cache of previous dead-end states,
but they still do not prevent these states from appearing in the DFS-stack,
just immediately marked as a dead end.).

The Server:
-----------

There will be one single server, which will be the first process to run,
and the clients (which will be based on libfreecell-solver.so) will all
connect for it and ask it for more to do, and more to delegate to clients
which are currently looking for something to help them with.

After setting up, the server accepts the connection from teh first client
to which it assigns the empty CoordSeq { depth == 0 }, then before
$CYCLE_LEN iterations, more clients ask to help other clients and the server
keeps their connection open. Then, the server asks the master client to
provide coordseqs to allocate for other clients, and they are allocated.
Occassionally, other clients will also ask for help and the server will help
them with.

Each client also reports on the currently reached CoordSeq and the server
keeps tracks (and logs) the initial CoordSeq allocated to each client and
its currently-reached CoordSeq.

The client allocates a CoordSeq by looking at the next states that need
to be traversed somewhere up the CoordSeq stack (a delta of
$DEPTH_ALLOC_DELTA from CoordSeq.depth or less), allocating the last (in the
following-chain of the current depth) non-allocated state as delegated,
marking it as delegated and delegating it.

Messages:
=========

This is a list of messages from server->client or from client->server. Every
message has a message ID (which can be implemented as a string or as a
fixed-size integer) and possibly some parameters.

CLIENT_INIT [client->server]
No parameters.

A client connects to the server and requests the initialisation.

---

GIVE_ID_TO_CLIENT
Parameters: id [64-bit int].

The server gives an ID to the client.

---




