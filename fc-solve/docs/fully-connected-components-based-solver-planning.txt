Irreversible moves:
-------------------

1. Moving a card from a freecell/column to the foundations.

2. Moving a card from an incompatible parent (by initial layout) to a different
freecell/column.

Reversible moves:
-----------------

All the rest.

Analysis of the game graph:
---------------------------

The game graph is a DAG (directed acyclic graph) of
fully-connected components (FCCs),
where the fully-connected components are composed of reversible moves and 
the edges between fully-connected components are irreversible moves.

Furthermore, in order to reach FCC we need to perform all the relevant 
irreversible moves that yielded it. As a result, one needs the same amount of
irreversible moves to reach a certain FCC so they can be sorted according to
their depth, which is measured by the number of irreversible moves.

Note that the depth of an FCC cannot exceed 52*2 which is the maximal number
of irreversible moves.

Represnting a Fully-connected Component:
----------------------------------------

typedef struct
{
    /* The minimal state in the fully-connected component, according to
    the lexical sorting of the encoded state keys. This is used to identify
    it and avoid collisions and re-processing. 
    */
    fcs_encoded_state_buffer_t min_by_sorting;
    /* The minimal state by absolute depth (including that of
    reversible moves). Not absolutely minimal, because the first
    $depth-1 FCC that reaches it, wins the jackpot.
    */
    fcs_encoded_state_buffer_t min_by_absolute_depth;
    /* Moves to the min_by_absolute_depth from the initial state. 
    (accumlative).
    */
    MOVE_STACK_T moves_to_min_by_absolute_depth;
} fcs_fully_connected_component_t;

The solver's state:
-------------------

struct
{
    struct prev_depth_FCCs
    {
        int fcc_depth_idx;
        List<fcs_fully_connected_component_t> to_scan_queue;
    };
    struct next_depth_FCCs
    {
        int fcc_depth_idx;
        Map{min_by_sorting => Bool Exists} DoesExists;
        List<fcs_fully_connected_component_t> queue;
        /* Optionally: */
        LRU_Map{any_state_in_the_FCCs => Bool Exists} Cache;
    };
} fcs_fcc_solver_state_t;

The algorithm:

#. FOREACH <prev_depth_FCCs.to_scan_queue >

#. Perform a BrFS from min_by_absolute_depth to find all the next FCC
startpoints (the positions in the graph that followed an irreversible move).

#. For each of these startpoints:

    #. Perform a BrFS scan to find the new FCC min_by_sorting (the scan will
    be only on reversible moves).
    
    #. ==> This is done while performing a lookup+insert for each state on
    next_depth_FCCs.Cache, and stopping if it's there.

    #. If it does not exist in next_depth_FCCs.DoesExists, add the new 
    min_by_sorting and min_by_absolute_depth (the start point) append a new FCC 
    to next_depth_FCCs.queue.

    #. If it does, halt the search for this startpoint.

#. END FOREACH <prev_depth_FCCs.to_scan_queue>

#. Free next_depth_FCCs.DoesExists , next_depth_FCCs.Cache.

#. Free prev_depth_FCCs.to_scan_queue.

#. prev_depth_FCCs.fcs_depth_idx = next_depth_FCCs.fcs_depth_idx

#. next_depth_FCCs.fcs_depth_idx++;

#. prev_depth_FCCs.to_scan_queue ‚Üê next_depth_FCCs.queue;

#. next_depth_FCCs.DoesExists = new empty one ; 
next_depth_FCCs.queue = new empty one ; 
next_depth_FCCs.Cache = new empty one ; 
