State Representation:
---------------------

As can be seen in state.h, Freecell Solver supports three ways to represent
a state:

1. Debug States - in this configuration, stack counters, and cards are
represented as 32-bit quantities. This configuration consumes a lot of memory,
and is the slowest of the three. It is however useful for debugging, as
the debugger will display the state data-structure very nicely.

2. Compact States - in this configuration the data is one buffer of chars,
where each card and each stack counter are represented as one character,
and each freecell and foundation is one char too.

Determining the locations of every card is done using offset calculation.

This configuration consumes much less memory than Debug States, but
it doesn't scale well to games where the stacks can contain a lot of cards.
The reason is that every stack be of a fixed size
(so offset would be determined by means of multiplication).

This configuration used to be the fastest for limited stack games such as 
Freecell. After Freecell Solver 2.6.x, it seems that Indirect Stack States 
has become slightly faster than it, too.

3. Indirect Stack States - in this configuration each stack is a pointer
to a stack in memory. The stacks are also collected and there is one copy
of each stack organization (say [KS QH 6H]) in memory. Since a pointer
to a stack uniquely identifies a stack, the states can be compared by
comparing their memory contents.

This is now the default configuration, and in the 2.5.x development tree,
many enhancments were done to optimize it. It was not benchmarked to be
slightly faster than Compact States, even for games like freecell.

Indirect Stack States Algorithms:
---------------------------------

The stacks are kept in their own stack collection in the f_s_instance
struct. When a test wishes to create a derived states, it first copies
the state, and then marks the flags of all the stacks as cleared. (check
(*Mark STACKS_COW_CLEAR *).

Later on when a stack is changed, its flag is set, and a stack is copied to a
hard-thread wide indirect stacks buffer and modified there. 
(check (*Mark STACKS_COW_COPY_STACK*) ).

The check_and_add_state function then, when checking a new state, ignores those
stacks whose flag was not set, and collects the stacks whose flag was set.
( (*Mark STACKS_COW_CACHING*) ). The memory for the collected stacks is
allocated compactly in a segment, where one stack starts after the other
(check alloc.c and alloc.h). If the stack was found in the collection
the memory that was allocated is freed for use by future stacks).


The States Graph and its Use:
-----------------------------

When a brand new state is discovered its parent is assigned to be the state
from which it is derived. (check (*Mark STATE_PARENT*)). Its depth
is assigned to be the depth of the parent + 1. There is a command line option
(--reparent-states) that specifies that if an existing state whose depth is
higher than the depth of state it was derived from + 1 is reached, then
its parent would be re-assigned.

An extended state has a num_active_children counter that specifies how many
of those states that consider it their parent were still not marked as dead 
ends. If this counter reaches 0, this state also becomed inactive.

The state has a vector of flags called scan_visited, that specifies if a given
scan has visited it yet. If it is a complete scan it can also mark it as 
dead end should it:

1. Recurse out of it if it's a DFS scan.

2. Find that it has no derived states if it is a Best-First Search scan.

If it is marked as dead end, then its parent's counter would be incremented.
If the latter is zero, the process may continue to the grand parent and so
forth.


